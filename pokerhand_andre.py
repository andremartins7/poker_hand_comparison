# -*- coding: utf-8 -*-
"""PokerHand_Andre.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-L9oGhHsjAzbp6mJjIyIfC7fVv6kY9ZZ

Este Notebook explora o desenvolvimento de um algoritmo para comparar duas mãos de pôquer de 5 cartas, para determinar qual é a mão vencedora. Possui um construtor que aceita uma String contendo 5 cartas.
"""

# mãos de teste em ordem crescente
# matriz de strings onde cada string é uma carta (valor e naipe)
test_hands = [
    ["AC", "5C", "10C", "7C", "3S"],
    ["2C", "3D", "4S", "5H", "2D"],
    ["2C", "3D", "4S", "3H", "2D"],
    ["5S", "4C", "AD", "4S", "4H"],
    ["3H", "7H", "6S", "4D", "5S"],
    ["AC", "5C", "10C", "7C", "3C"],
    ["5C", "8D", "5H", "8S", "8H"],
    ["3D", "7H", "7S", "7C", "7D"],
    ["AS", "10S", "QS", "KS", "JS"],
]

# função que recebe uma carta e retorna o seu naipe
def suit(card):
  return card[-1]

# testando a função suit
suit("AC")

# testando a função suit
suit("10D")

# função para obter as cartas e retornar os seus valores
def value(card):
  if card[0] == "A":
    return 14
  if card[0] == "J":
    return 11
  if card[0] == "Q":
    return 12
  if card[0] == "K":
    return 13
  if card[0] == "T":
    return 10
  return int(card[0:-1])

# testando a função value
value("AC")

# testando a função value
value("10D")

# determinar se é um flush ou casos especiais
# verifica se todas as cartas menos a primeira são do mesmo naipe
def is_flush(cards):
  return all([suit(card) == suit(cards[0]) for card in cards[1:]])

# testando a função is_flush
[is_flush(hand) for hand in test_hands]

# distribuição de mãos das cartas usando dicionário
def hand_dist(cards):
  dist = {i:0 for i in range(1, 15)}
  for card in cards:
    dist[value(card)] += 1
  dist[1] = dist[14]
  return dist

# testando a função hand_dist
[hand_dist(hand) for hand in test_hands]

# função que retorna o valor mais alto se for uma sequência
def straight_high_card(cards):
  dist = hand_dist(cards)
  for value in range(1, 11):
    if all([dist[value + k] == 1 for k in range(5)]):
      return value + 4
      
  return None

# testando a função straight_high_card
[straight_high_card(hand) for hand in test_hands]

# função que conta o número de cartas
def card_count(cards, num, but=None):
  dist = hand_dist(cards)
  for value in range(2, 15):
    if value == but:
      continue
    if dist[value] == num:
      return value
  return None

# testando a função card_count
[card_count(hand, 2, 2) for hand in test_hands]

# classificação de mão para um conjunto de cartas
def hand_rank(cards):
  if straight_high_card(cards) is not None and is_flush(cards):
    return 8
  if card_count(cards, 4) is not None:
    return 7
  if card_count(cards, 3) is not None and card_count(cards, 2) is not None:
    return 6
  if is_flush(cards):
    return 5
  if straight_high_card(cards) is not None:
    return 4
  if card_count(cards, 3) is not None:
    return 3
  pair1 = card_count(cards, 2)
  if pair1 is not None:
    if card_count(cards, 2, but=pair1) is not None:
      return 2
    return 1
  return 0

# teste da função de classificação de mão
[hand_rank(hand) for hand in test_hands]

# função de comparação entre duas mãos
def compare_hands(hand1, hand2):
  r1 = hand_rank(hand1)
  r2 = hand_rank(hand2)
  if r1 < r2:
    return -1
  if r1 > r2:
    return 1
  # Precisa adicionar teste para high cards - desempate
  return 0

# teste da função de comparação
compare_hands(test_hands[4], test_hands[4])

# função para embaralhar as cartas
def make_deck():
  deck = []
  for suit in ("D", "C", "H", "S"):
    for value in range(2, 15):
      if value < 11:
        value_string = str(value)
      else:
        value_string = ("J", "Q", "K", "A", "T")[value - 10]
      deck.append(value_string + suit)
  return deck

# verifica se existem 52 cartas no baralho
len(make_deck())

# importando a biblioteca randomica
import random

# cria um baralho embaralhado aleatoriamente
def shuffled_deck():
  deck = make_deck()
  random.shuffle(deck)
  return deck

# testando o embaralhamento
shuffled_deck()

# função para distribuir as cartas
def deal(deck, n):
  hand = deck[0:n]
  del deck[0:n]
  return hand

# gera um baralho igual ao embaralhado
deck = shuffled_deck()
deck

# baralho com cinco primeiras cartas
deal(deck, 5)

# teste que verifica quantas cartas restam no baralho
len(deck)

# teste que verifica quais as cartas que restam no baralho
deck

# classifica por nomes
rank_names = ["high card", "pair", "two pair", "three of a kind", "straight", 
              "flush", "full house", "four of a kind", "straight flush"]

# função de comparação entre as duas mãos
def show_compare_hands(hand1, hand2):
  sgn = compare_hands(hand1, hand2)
  result = ("loses to", "ties", "beats")[sgn + 1]
  print(f'{hand1} {result} {hand2}')
  r1 = hand_rank(hand1)
  r2 = hand_rank(hand2)
  print(f'{rank_names[r1]} {result} {rank_names[r2]}')

# pega as duas mãos com o baralho de cinco cartas
hand1 = deal(deck, 5)
hand2 = deal(deck, 5)

hand1

hand2

# compara as duas mãos
show_compare_hands(hand1, hand2)

# gera casos de testes aleatórios
def test_random_hands(n=20):
  for i in range(n):
    deck = shuffled_deck()
    show_compare_hands(deal(deck, 5), deal(deck, 5))

# visualiza os testes
test_random_hands()